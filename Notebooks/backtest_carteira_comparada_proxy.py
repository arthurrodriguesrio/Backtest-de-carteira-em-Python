# -*- coding: utf-8 -*-
"""Backtest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q_JErgPR24JTpcIj6O20Kr7Hy7yshVyW
"""

import numpy as np
import pandas as pd

cotacoes = pd.read_csv('cotacoes_empresas_fator.csv')
carteira = pd.read_csv('carteira_fator_recomendacoes.csv')

cotacoes.head()

cotacoes.info()

carteira.head()

carteira.info()



"""# **Tratamento e padronização de datas**"""

cotacoes['data'] = pd.to_datetime(cotacoes['data'])
carteira['data'] = pd.to_datetime(carteira['data'])

# Datas em ordem temporal e cronológica

cotacoes.info()

carteira.info()



"""# **Cálculo diário**"""

cotacoes = cotacoes.sort_values(by=['ticker', 'data'])
carteira = carteira.sort_values(by=['data', 'ticker'])

# Ordenamento das linhas a partir das colunas mencioadas

cotacoes['retorno'] = (
    cotacoes.groupby('ticker')['preco_fechamento_ajustado_desdobramentos'].pct_change()
)

# Criaçaõ coluna 'retorno' por ticker e preço de fechamento
# resultando na variação em relação ao dia anterior

cotacoes.head()

"""# **Cruzamento e aplicação de peso**"""

df = cotacoes.merge(carteira, on='ticker', how='left', suffixes=('_cotacoes', '_carteira'))
# Jução de df usando ticker como chave

df = df.dropna(subset=['peso'])
# Remoção de linhas sem peso

df = df[df['data_cotacoes'] >= df['data_carteira']]
# Manter apenas dados após a recomendação

df['peso_normalizado'] = (
    df['peso'] /
    df.groupby('data_cotacoes')['peso'].transform('sum')
    )
# Ajuste proporcional de peso

df['retorno_ponderado'] = df['retorno'] * df['peso_normalizado']
# Define retorno ponderado a partir do retorno e do peso tratado

df.head()

retorno_diario = (
    df.groupby('data_cotacoes')['retorno_ponderado']
    .sum()
    .reset_index()
    .rename(columns = {
        'data_cotacoes': 'data',
        'retorno_ponderado': 'retorno_diario'
    })
    )

retorno_diario.head()

"""# **Cálculo de cota diário**"""

retorno_diario['cota'] = (1 + retorno_diario['retorno_diario']).cumprod()*100
# Cálculo de cota acumulada

retorno_diario.head()

resultado_carteira = retorno_diario[['data','cota','retorno_diario']]

resultado_carteira

resultado_carteira.to_csv('resultado_carteira.csv', index=False)



"""# **Informações do proxy**"""

import yfinance as yf

smal11 = yf.download('SMAL11.SA', start=resultado_carteira['data'].min())

smal11 = smal11.reset_index()
# Resetando, transformando data em coluna

smal11.columns = smal11.columns.get_level_values(0)
# Para acessar apenas o nível 0 das colunas

smal11 = smal11.rename(columns={'Date':'data', 'Close':'preco_fechamento'})
# data -> datatime

smal11['retorno_diario_indice'] = smal11['preco_fechamento'].pct_change()
# Cálculo de retorno diário

smal11['cota_indice'] = (1 + smal11['retorno_diario_indice']).cumprod() * 100
# Cálculo de cota acumulada

smal11



"""# **Carteira x Proxy**"""

comparacao = resultado_carteira.merge(
    smal11[['data', 'cota_indice']],
    on='data',
    how='inner',
    )

resultado_carteira.head()

comparacao

comparacao.to_csv('comparacao_carteira_indice.csv', index=False)

print("Carteira final:", comparacao['cota'].iloc[-1])
print("Índice final:", comparacao['cota_indice'].iloc[-1])

"""# **Comparação gráfica**"""

import matplotlib.pyplot as plt

plt.figure()

plt.plot(
    comparacao['data'],
    comparacao['cota'],
    label='Carteira'
)

# Linha da carteira

plt.plot(
    comparacao['data'],
    comparacao['cota_indice'],
    label='SMAL11'
)

# Linha do proxy (SMAL11)

plt.xlabel('Data')
plt.ylabel('Cota')
plt.title('Evolução da Cota: Carteira Recomendada vs SMAL11')
# Títulos e rótulos

plt.legend()
# Legenda

plt.xticks(rotation=45)
# Melhor visualização das datas

plt.tight_layout()
# Ajuste automático de margens

plt.show()
# Exibição do gráfico

